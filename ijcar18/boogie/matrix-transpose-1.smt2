(reset)
(set-option :print-success false)
(set-info :smt-lib-version 2.0)
(set-info :status unsat)
(set-option :AUTO_CONFIG false)
(set-option :pp.bv_literals false)
(set-option :MODEL.V2 true)
(set-option :smt.PHASE_SELECTION 0)
(set-option :smt.RESTART_STRATEGY 0)
(set-option :smt.RESTART_FACTOR |1.5|)
(set-option :smt.ARITH.RANDOM_INITIAL_VALUE true)
(set-option :smt.CASE_SPLIT 3)
(set-option :smt.DELAY_UNITS true)
(set-option :NNF.SK_HACK true)
(set-option :smt.MBQI false)
(set-option :smt.QI.EAGER_THRESHOLD 100)
(set-option :TYPE_CHECK true)
(set-option :smt.BV.REFLECT true)
; done setting options


(declare-fun tickleBool (Bool) Bool)
(assert (and (tickleBool true) (tickleBool false)))
(declare-fun %lbl%+460 () Bool)
(declare-fun %lbl%@1052 () Bool)
(declare-fun bad@0 () Bool)
(declare-fun row@1 () Int)
(declare-fun col@2 () Int)
(declare-fun %lbl%@1066 () Bool)
(declare-fun size () Int)
(declare-fun transposed@3 () (Array Int (Array Int Int)))
(declare-fun matrix () (Array Int (Array Int Int)))
(declare-fun %lbl%+259 () Bool)
(declare-fun col () Int)
(declare-fun row@0 () Int)
(declare-fun row () Int)
(declare-fun col@1 () Int)
(declare-fun transposed@2 () (Array Int (Array Int Int)))
(declare-fun transposed () (Array Int (Array Int Int)))
(declare-fun %lbl%+257 () Bool)
(declare-fun transposed@0 () (Array Int (Array Int Int)))
(declare-fun transposed@1 () (Array Int (Array Int Int)))
(declare-fun col@0 () Int)
(declare-fun %lbl%+248 () Bool)
(declare-fun bad () Bool)
(declare-fun %lbl%+246 () Bool)
(declare-fun %lbl%+464 () Bool)
(push 1)
(set-info :boogie-vc-id main)
(assert (not
(let ((GeneratedUnifiedExit_correct  (=> (! (and %lbl%+460 true) :lblpos +460) (and (! (or %lbl%@1052  (or bad@0 (and (<= 0 row@1) (<= row@1 col@2)))) :lblneg @1052) (=> (or bad@0 (and (<= 0 row@1) (<= row@1 col@2))) (! (or %lbl%@1066  (or bad@0 (forall ((i Int) (j Int) ) (!  (=> (and (and (and (<= 0 i) (<= i j)) (< j size)) (or (and (= i row@1) (< j col@2)) (< i row@1))) (and (= (select (select transposed@3 i) j) (select (select matrix j) i)) (= (select (select transposed@3 j) i) (select (select matrix i) j))))
 :qid |matrixtr.15:26|
 :skolemid |1|
)))) :lblneg @1066))))))
(let ((anon6_Else_correct  (=> (! (and %lbl%+259 true) :lblpos +259) (=> (<= size col) (=> (and (= row@0 (+ row 1)) (= col@1 (+ row@0 1))) (=> (and (and (= transposed@2 (store transposed row@0 (store (select transposed row@0) row@0 (select (select matrix row@0) row@0)))) (= row@1 row@0)) (and (= transposed@3 transposed@2) (= col@2 col@1))) GeneratedUnifiedExit_correct))))))
(let ((anon6_Then_correct  (=> (! (and %lbl%+257 true) :lblpos +257) (=> (< col size) (=> (and (= transposed@0 (store transposed row (store (select transposed row) col (select (select matrix col) row)))) (= transposed@1 (store transposed@0 col (store (select transposed@0 col) row (select (select matrix row) col))))) (=> (and (and (= col@0 (+ col 1)) (= row@1 row)) (and (= transposed@3 transposed@1) (= col@2 col@0))) GeneratedUnifiedExit_correct))))))
(let ((anon5_Else_correct  (=> (! (and %lbl%+248 true) :lblpos +248) (=> (not (= row size)) (=> (and (=> bad@0 bad) (=> bad bad@0)) (and anon6_Then_correct anon6_Else_correct))))))
(let ((anon5_Then_correct  (=> (! (and %lbl%+246 true) :lblpos +246) (=> (not (not (= row size))) (=> (and (=> bad@0 true) (=> true bad@0)) (and anon6_Then_correct anon6_Else_correct))))))
(let ((anon0_correct  (=> (! (and %lbl%+464 true) :lblpos +464) (=> (> size 0) (=> (and (and (<= 0 row) (<= row col)) (forall ((i@@0 Int) (j@@0 Int) ) (!  (=> (and (and (and (<= 0 i@@0) (<= i@@0 j@@0)) (< j@@0 size)) (or (and (= i@@0 row) (< j@@0 col)) (< i@@0 row))) (and (= (select (select transposed i@@0) j@@0) (select (select matrix j@@0) i@@0)) (= (select (select transposed j@@0) i@@0) (select (select matrix i@@0) j@@0))))
 :qid |matrixtr.11:20|
 :skolemid |0|
))) (and anon5_Then_correct anon5_Else_correct))))))
anon0_correct))))))
))
(get-info :name)
(check-sat)
(get-info :name)
(pop 1)
; Valid
